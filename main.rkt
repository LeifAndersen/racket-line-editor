#lang racket/base
(module+ test
  (check-true ; Get Cursor Position
   (let ([cols
          (let ()
            (file-stream-buffer-mode (current-input-port) 'none)
            (file-stream-buffer-mode (current-output-port) 'none)
            (void (tty-raw!))
            (define cols (get-cursor-position))
            (void (tty-restore!))
            cols)])
     (and (pair? cols) (number? (first cols)) (= (length cols) 2)
        (number? (second cols)))))
  (check-true ; Get columns
   (< 0
      (let ()
        (file-stream-buffer-mode (current-input-port) 'none)
        (file-stream-buffer-mode (current-output-port) 'none)
        (void (tty-raw!))
        (define cols (get-columns))
        (void (tty-restore!))
        cols)))
  (check-true ; Get cursor position
   (pair?
    (let ()
      (file-stream-buffer-mode (current-input-port) 'none)
      (file-stream-buffer-mode (current-output-port) 'none)
      (void (tty-raw!))
      (define x (get-cursor-position))
      (void (tty-restore!))
      x)))
  (check-equal? ; Display prompt
   (call-with-output-string
    (lambda (stdout)
      (file-stream-buffer-mode stdin 'none)
      (void (tty-raw!))
      (define state (le-state stdin stdout "" "foo>" 0 0 0 (get-columns stdin) 0 0))
      (refresh-line! state)
      (void (tty-restore!))))
   "\rfoo>\e[0K\r\e[4C")
  (check-equal? ; type characters
   (call-with-output-string
    (lambda (stdout)
      (file-stream-buffer-mode stdin 'none)
      (void (tty-raw!))
      (define state (le-state stdin stdout "" "foo>" 0 0 0 (get-columns stdin) 0 0))
      (edit-insert! state #\h)
      (edit-insert! state #\e)
      (edit-insert! state #\l)
      (edit-insert! state #\l)
      (edit-insert! state #\o)
      (refresh-line! state)
      (void (tty-restore!))))
   "hello\rfoo>hello\e[0K\r\e[9C")
  (check-equal? ; Backspace
   (call-with-output-string
    (lambda (stdout)
      (file-stream-buffer-mode stdin 'none)
      (void (tty-raw!))
      (define state (le-state stdin stdout "" "foo>" 0 0 0 (get-columns stdin) 0 0))
      (edit-insert! state #\y)
      (edit-insert! state #\e)
      (edit-backspace! state)
      (edit-backspace! state)
      (edit-insert! state #\n)
      (edit-insert! state #\o)
      (refresh-line! state)
      (void (tty-restore!))))
   "ye\rfoo>y\e[0K\r\e[5C\rfoo>\e[0K\r\e[4Cno\rfoo>no\e[0K\r\e[6C")
  (check-equal? ; left arrow key
   (call-with-output-string
    (lambda (stdout)
      (file-stream-buffer-mode stdin 'none)
      (void (tty-raw!))
      (define state (le-state stdin stdout "" "foo>" 0 0 0 (get-columns stdin) 0 0))
      (edit-insert! state #\y)
      (edit-insert! state #\s)
      (edit-move-left! state)
      (edit-insert! state #\e)
      (refresh-line! state)
      (void (tty-restore!))))
   "ys\rfoo>ys\e[0K\r\e[5C\rfoo>yes\e[0K\r\e[6C\rfoo>yes\e[0K\r\e[6C")
  (check-equal? ; cat
   (call-with-output-string
    (lambda (stdout)
      (file-stream-buffer-mode stdin 'none)
      (void (tty-raw!))
      (define state (le-state stdin stdout "" "foo>" 0 0 0 (get-columns stdin) 0 0))
      (edit-insert! state #\o)
      (edit-move-left! state)
      (edit-insert! state #\a)
      (edit-delete! state)
      (edit-move-left! state)
      (edit-insert! state #\c)
      (edit-move-right! state)
      (edit-insert! state #\t)
      (refresh-line! state)
      (void (tty-restore!))))
   "o\rfoo>o\e[0K\r\e[4C\rfoo>ao\e[0K\r\e[5C\rfoo>a\e[0K\r\e[5C\rfoo>a\e[0K\r\e[4C\rfoo>ca\e[0K\r\e[5C\rfoo>ca\e[0K\r\e[6Ct\rfoo>cat\e[0K\r\e[7C")
   )

